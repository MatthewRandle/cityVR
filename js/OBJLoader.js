THREE.OBJLoader = function () { var D = /^[og]\s*(.+)?/, k = /^mtllib /, q = /^usemtl /, K = /^usemap /; function Q() { var t = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materialLibraries: [], startObject: function (t, e) { if (this.object && !1 === this.object.fromDeclaration) return this.object.name = t, void (this.object.fromDeclaration = !1 !== e); var r = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0; if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = { name: t || "", fromDeclaration: !1 !== e, geometry: { vertices: [], normals: [], colors: [], uvs: [] }, materials: [], smooth: !0, startMaterial: function (t, e) { var r = this._finalize(!1); r && (r.inherited || r.groupCount <= 0) && this.materials.splice(r.index, 1); var i = { index: this.materials.length, name: t || "", mtllib: Array.isArray(e) && 0 < e.length ? e[e.length - 1] : "", smooth: void 0 !== r ? r.smooth : this.smooth, groupStart: void 0 !== r ? r.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: !1, clone: function (t) { var e = { index: "number" == typeof t ? t : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: !1 }; return e.clone = this.clone.bind(e), e } }; return this.materials.push(i), i }, currentMaterial: function () { if (0 < this.materials.length) return this.materials[this.materials.length - 1] }, _finalize: function (t) { var e = this.currentMaterial(); if (e && -1 === e.groupEnd && (e.groupEnd = this.geometry.vertices.length / 3, e.groupCount = e.groupEnd - e.groupStart, e.inherited = !1), t && 1 < this.materials.length) for (var r = this.materials.length - 1; 0 <= r; r--)this.materials[r].groupCount <= 0 && this.materials.splice(r, 1); return t && 0 === this.materials.length && this.materials.push({ name: "", smooth: this.smooth }), e } }, r && r.name && "function" == typeof r.clone) { var i = r.clone(0); i.inherited = !0, this.object.materials.push(i) } this.objects.push(this.object) }, finalize: function () { this.object && "function" == typeof this.object._finalize && this.object._finalize(!0) }, parseVertexIndex: function (t, e) { var r = parseInt(t, 10); return 3 * (0 <= r ? r - 1 : r + e / 3) }, parseNormalIndex: function (t, e) { var r = parseInt(t, 10); return 3 * (0 <= r ? r - 1 : r + e / 3) }, parseUVIndex: function (t, e) { var r = parseInt(t, 10); return 2 * (0 <= r ? r - 1 : r + e / 2) }, addVertex: function (t, e, r) { var i = this.vertices, s = this.object.geometry.vertices; s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[r + 0], i[r + 1], i[r + 2]) }, addVertexPoint: function (t) { var e = this.vertices; this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2]) }, addVertexLine: function (t) { var e = this.vertices; this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2]) }, addNormal: function (t, e, r) { var i = this.normals, s = this.object.geometry.normals; s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[r + 0], i[r + 1], i[r + 2]) }, addColor: function (t, e, r) { var i = this.colors, s = this.object.geometry.colors; s.push(i[t + 0], i[t + 1], i[t + 2]), s.push(i[e + 0], i[e + 1], i[e + 2]), s.push(i[r + 0], i[r + 1], i[r + 2]) }, addUV: function (t, e, r) { var i = this.uvs, s = this.object.geometry.uvs; s.push(i[t + 0], i[t + 1]), s.push(i[e + 0], i[e + 1]), s.push(i[r + 0], i[r + 1]) }, addUVLine: function (t) { var e = this.uvs; this.object.geometry.uvs.push(e[t + 0], e[t + 1]) }, addFace: function (t, e, r, i, s, a, o, n, l) { var h = this.vertices.length, c = this.parseVertexIndex(t, h), u = this.parseVertexIndex(e, h), p = this.parseVertexIndex(r, h); if (this.addVertex(c, u, p), 0 < this.colors.length && this.addColor(c, u, p), void 0 !== i && "" !== i) { var m = this.uvs.length; c = this.parseUVIndex(i, m), u = this.parseUVIndex(s, m), p = this.parseUVIndex(a, m), this.addUV(c, u, p) } if (void 0 !== o && "" !== o) { var f = this.normals.length; c = this.parseNormalIndex(o, f), u = o === n ? c : this.parseNormalIndex(n, f), p = o === l ? c : this.parseNormalIndex(l, f), this.addNormal(c, u, p) } }, addPointGeometry: function (t) { this.object.geometry.type = "Points"; for (var e = this.vertices.length, r = 0, i = t.length; r < i; r++)this.addVertexPoint(this.parseVertexIndex(t[r], e)) }, addLineGeometry: function (t, e) { this.object.geometry.type = "Line"; for (var r = this.vertices.length, i = this.uvs.length, s = 0, a = t.length; s < a; s++)this.addVertexLine(this.parseVertexIndex(t[s], r)); var o = 0; for (a = e.length; o < a; o++)this.addUVLine(this.parseUVIndex(e[o], i)) } }; return t.startObject("", !1), t } function t(t) { THREE.Loader.call(this, t), this.materials = null } return t.prototype = Object.assign(Object.create(THREE.Loader.prototype), { constructor: t, load: function (t, e, r, i) { var s = this, a = new THREE.FileLoader(s.manager); a.setPath(this.path), a.load(t, function (t) { e(s.parse(t)) }, r, i) }, setMaterials: function (t) { return this.materials = t, this }, parse: function (t) { console.time("OBJLoader"); var e = new Q; -1 !== t.indexOf("\r\n") && (t = t.replace(/\r\n/g, "\n")), -1 !== t.indexOf("\\\n") && (t = t.replace(/\\\n/g, "")); for (var r = t.split("\n"), i = "", s = "", a = [], o = "function" == typeof "".trimLeft, n = 0, l = r.length; n < l; n++)if (i = r[n], 0 !== (i = o ? i.trimLeft() : i.trim()).length && "#" !== (s = i.charAt(0))) if ("v" === s) { var h = i.split(/\s+/); switch (h[0]) { case "v": e.vertices.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), 7 <= h.length && e.colors.push(parseFloat(h[4]), parseFloat(h[5]), parseFloat(h[6])); break; case "vn": e.normals.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])); break; case "vt": e.uvs.push(parseFloat(h[1]), parseFloat(h[2])) } } else if ("f" === s) { for (var c = i.substr(1).trim().split(/\s+/), u = [], p = 0, m = c.length; p < m; p++) { var f = c[p]; if (0 < f.length) { var d = f.split("/"); u.push(d) } } var v = u[0]; for (p = 1, m = u.length - 1; p < m; p++) { var g = u[p], b = u[p + 1]; e.addFace(v[0], g[0], b[0], v[1], g[1], b[1], v[2], g[2], b[2]) } } else if ("l" === s) { var E = i.substring(1).trim().split(" "), j = [], x = []; if (-1 === i.indexOf("/")) j = E; else for (var y = 0, T = E.length; y < T; y++) { var L = E[y].split("/"); "" !== L[0] && j.push(L[0]), "" !== L[1] && x.push(L[1]) } e.addLineGeometry(j, x) } else if ("p" === s) { var R = i.substr(1).trim().split(" "); e.addPointGeometry(R) } else if (null !== (a = D.exec(i))) { var H = (" " + a[0].substr(1).trim()).substr(1); e.startObject(H) } else if (q.test(i)) e.object.startMaterial(i.substring(7).trim(), e.materialLibraries); else if (k.test(i)) e.materialLibraries.push(i.substring(7).trim()); else if (K.test(i)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'); else { if ("s" !== s) { if ("\0" === i) continue; throw new Error('THREE.OBJLoader: Unexpected line: "' + i + '"') } if (1 < (a = i.split(" ")).length) { var w = a[1].trim().toLowerCase(); e.object.smooth = "0" !== w && "off" !== w } else e.object.smooth = !0; (S = e.object.currentMaterial()) && (S.smooth = e.object.smooth) } e.finalize(); var V = new THREE.Group; V.materialLibraries = [].concat(e.materialLibraries); for (n = 0, l = e.objects.length; n < l; n++) { var M = e.objects[n], F = M.geometry, I = M.materials, A = "Line" === F.type, B = "Points" === F.type, O = !1; if (0 !== F.vertices.length) { var P = new THREE.BufferGeometry; P.setAttribute("position", new THREE.Float32BufferAttribute(F.vertices, 3)), 0 < F.normals.length ? P.setAttribute("normal", new THREE.Float32BufferAttribute(F.normals, 3)) : P.computeVertexNormals(), 0 < F.colors.length && (O = !0, P.setAttribute("color", new THREE.Float32BufferAttribute(F.colors, 3))), 0 < F.uvs.length && P.setAttribute("uv", new THREE.Float32BufferAttribute(F.uvs, 2)); for (var z, C = [], U = 0, N = I.length; U < N; U++) { var G = I[U], S = void 0; if (null !== this.materials) if (S = this.materials.create(G.name), !A || !S || S instanceof THREE.LineBasicMaterial) { if (B && S && !(S instanceof THREE.PointsMaterial)) { var _ = new THREE.PointsMaterial({ size: 10, sizeAttenuation: !1 }); THREE.Material.prototype.copy.call(_, S), _.color.copy(S.color), _.map = S.map, S = _ } } else { var J = new THREE.LineBasicMaterial; THREE.Material.prototype.copy.call(J, S), J.color.copy(S.color), S = J } S || ((S = A ? new THREE.LineBasicMaterial : B ? new THREE.PointsMaterial({ size: 1, sizeAttenuation: !1 }) : new THREE.MeshPhongMaterial).name = G.name), S.flatShading = !G.smooth, S.vertexColors = O ? THREE.VertexColors : THREE.NoColors, C.push(S) } if (1 < C.length) { for (U = 0, N = I.length; U < N; U++) { G = I[U]; P.addGroup(G.groupStart, G.groupCount, U) } z = A ? new THREE.LineSegments(P, C) : B ? new THREE.Points(P, C) : new THREE.Mesh(P, C) } else z = A ? new THREE.LineSegments(P, C[0]) : B ? new THREE.Points(P, C[0]) : new THREE.Mesh(P, C[0]); z.name = M.name, V.add(z) } } return console.timeEnd("OBJLoader"), V } }), t }();